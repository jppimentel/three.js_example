{"ast":null,"code":"/**\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\nimport { BufferAttribute, BufferGeometry, LineSegments, Mesh, Points } from \"../../../../../build/three.module.js\";\n/**\n *\n * @param {MaterialHandler} materialHandler\n * @constructor\n */\n\nvar MeshReceiver = function MeshReceiver(materialHandler) {\n  this.logging = {\n    enabled: false,\n    debug: false\n  };\n  this.callbacks = {\n    onProgress: null,\n    onMeshAlter: null\n  };\n  this.materialHandler = materialHandler;\n};\n\nMeshReceiver.prototype = {\n  constructor: MeshReceiver,\n\n  /**\n   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n   *\n   * @param {boolean} enabled True or false.\n   * @param {boolean} debug True or false.\n   */\n  setLogging: function setLogging(enabled, debug) {\n    this.logging.enabled = enabled === true;\n    this.logging.debug = debug === true;\n  },\n\n  /**\n   *\n   * @param {Function} onProgress\n   * @param {Function} onMeshAlter\n   * @private\n   */\n  _setCallbacks: function _setCallbacks(onProgress, onMeshAlter) {\n    if (onProgress !== null && onProgress !== undefined && onProgress instanceof Function) {\n      this.callbacks.onProgress = onProgress;\n    }\n\n    if (onMeshAlter !== null && onMeshAlter !== undefined && onMeshAlter instanceof Function) {\n      this.callbacks.onMeshAlter = onMeshAlter;\n    }\n  },\n\n  /**\n   * Builds one or multiple meshes from the data described in the payload (buffers, params, material info).\n   *\n   * @param {Object} meshPayload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n   * @returns {Mesh[]} mesh Array of {@link Mesh}\n   */\n  buildMeshes: function buildMeshes(meshPayload) {\n    var meshName = meshPayload.params.meshName;\n    var buffers = meshPayload.buffers;\n    var bufferGeometry = new BufferGeometry();\n\n    if (buffers.vertices !== undefined && buffers.vertices !== null) {\n      bufferGeometry.setAttribute('position', new BufferAttribute(new Float32Array(buffers.vertices), 3));\n    }\n\n    if (buffers.indices !== undefined && buffers.indices !== null) {\n      bufferGeometry.setIndex(new BufferAttribute(new Uint32Array(buffers.indices), 1));\n    }\n\n    if (buffers.colors !== undefined && buffers.colors !== null) {\n      bufferGeometry.setAttribute('color', new BufferAttribute(new Float32Array(buffers.colors), 3));\n    }\n\n    if (buffers.normals !== undefined && buffers.normals !== null) {\n      bufferGeometry.setAttribute('normal', new BufferAttribute(new Float32Array(buffers.normals), 3));\n    } else {\n      bufferGeometry.computeVertexNormals();\n    }\n\n    if (buffers.uvs !== undefined && buffers.uvs !== null) {\n      bufferGeometry.setAttribute('uv', new BufferAttribute(new Float32Array(buffers.uvs), 2));\n    }\n\n    if (buffers.skinIndex !== undefined && buffers.skinIndex !== null) {\n      bufferGeometry.setAttribute('skinIndex', new BufferAttribute(new Uint16Array(buffers.skinIndex), 4));\n    }\n\n    if (buffers.skinWeight !== undefined && buffers.skinWeight !== null) {\n      bufferGeometry.setAttribute('skinWeight', new BufferAttribute(new Float32Array(buffers.skinWeight), 4));\n    }\n\n    var material, materialName, key;\n    var materialNames = meshPayload.materials.materialNames;\n    var createMultiMaterial = meshPayload.materials.multiMaterial;\n    var multiMaterials = [];\n\n    for (key in materialNames) {\n      materialName = materialNames[key];\n      material = this.materialHandler.getMaterial(materialName);\n      if (createMultiMaterial) multiMaterials.push(material);\n    }\n\n    if (createMultiMaterial) {\n      material = multiMaterials;\n      var materialGroups = meshPayload.materials.materialGroups;\n      var materialGroup;\n\n      for (key in materialGroups) {\n        materialGroup = materialGroups[key];\n        bufferGeometry.addGroup(materialGroup.start, materialGroup.count, materialGroup.index);\n      }\n    }\n\n    var meshes = [];\n    var mesh;\n    var callbackOnMeshAlterResult;\n    var useOrgMesh = true;\n    var geometryType = meshPayload.geometryType === null ? 0 : meshPayload.geometryType;\n\n    if (this.callbacks.onMeshAlter) {\n      callbackOnMeshAlterResult = this.callbacks.onMeshAlter({\n        detail: {\n          meshName: meshName,\n          bufferGeometry: bufferGeometry,\n          material: material,\n          geometryType: geometryType\n        }\n      });\n    } // here LoadedMeshUserOverride is required to be provided by the callback used to alter the results\n\n\n    if (callbackOnMeshAlterResult) {\n      if (callbackOnMeshAlterResult.isDisregardMesh()) {\n        useOrgMesh = false;\n      } else if (callbackOnMeshAlterResult.providesAlteredMeshes()) {\n        for (var i in callbackOnMeshAlterResult.meshes) {\n          meshes.push(callbackOnMeshAlterResult.meshes[i]);\n        }\n\n        useOrgMesh = false;\n      }\n    }\n\n    if (useOrgMesh) {\n      if (meshPayload.computeBoundingSphere) bufferGeometry.computeBoundingSphere();\n\n      if (geometryType === 0) {\n        mesh = new Mesh(bufferGeometry, material);\n      } else if (geometryType === 1) {\n        mesh = new LineSegments(bufferGeometry, material);\n      } else {\n        mesh = new Points(bufferGeometry, material);\n      }\n\n      mesh.name = meshName;\n      meshes.push(mesh);\n    }\n\n    var progressMessage = meshPayload.params.meshName;\n\n    if (meshes.length > 0) {\n      var meshNames = [];\n\n      for (var _i in meshes) {\n        mesh = meshes[_i];\n        meshNames[_i] = mesh.name;\n      }\n\n      progressMessage += ': Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;\n      progressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';\n    } else {\n      progressMessage += ': Not adding mesh: ' + meshName;\n      progressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';\n    }\n\n    if (this.callbacks.onProgress) {\n      this.callbacks.onProgress('progress', progressMessage, meshPayload.progress.numericalValue);\n    }\n\n    return meshes;\n  }\n};\n/**\n * Object to return by callback onMeshAlter. Used to disregard a certain mesh or to return one to many meshes.\n * @class\n *\n * @param {boolean} disregardMesh=false Tell implementation to completely disregard this mesh\n * @param {boolean} disregardMesh=false Tell implementation that mesh(es) have been altered or added\n */\n\nvar LoadedMeshUserOverride = function LoadedMeshUserOverride(disregardMesh, alteredMesh) {\n  this.disregardMesh = disregardMesh === true;\n  this.alteredMesh = alteredMesh === true;\n  this.meshes = [];\n};\n\nLoadedMeshUserOverride.prototype = {\n  constructor: LoadedMeshUserOverride,\n\n  /**\n   * Add a mesh created within callback.\n   *\n   * @param {Mesh} mesh\n   */\n  addMesh: function addMesh(mesh) {\n    this.meshes.push(mesh);\n    this.alteredMesh = true;\n  },\n\n  /**\n   * Answers if mesh shall be disregarded completely.\n   *\n   * @returns {boolean}\n   */\n  isDisregardMesh: function isDisregardMesh() {\n    return this.disregardMesh;\n  },\n\n  /**\n   * Answers if new mesh(es) were created.\n   *\n   * @returns {boolean}\n   */\n  providesAlteredMeshes: function providesAlteredMeshes() {\n    return this.alteredMesh;\n  }\n};\nexport { MeshReceiver, LoadedMeshUserOverride };","map":null,"metadata":{},"sourceType":"module"}