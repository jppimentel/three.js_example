{"ast":null,"code":"/**\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\n/**\n * Parse OBJ data either from ArrayBuffer or string\n */\nvar OBJLoader2Parser = function OBJLoader2Parser() {\n  this.logging = {\n    enabled: false,\n    debug: false\n  };\n  var scope = this;\n  this.callbacks = {\n    onProgress: function onProgress(text) {\n      scope._onProgress(text);\n    },\n    onAssetAvailable: function onAssetAvailable(payload) {\n      scope._onAssetAvailable(payload);\n    },\n    onError: function onError(errorMessage) {\n      scope._onError(errorMessage);\n    },\n    onLoad: function onLoad(object3d, message) {\n      scope._onLoad(object3d, message);\n    }\n  };\n  this.contentRef = null;\n  this.legacyMode = false;\n  this.materials = {};\n  this.materialPerSmoothingGroup = false;\n  this.useOAsMesh = false;\n  this.useIndices = false;\n  this.disregardNormals = false;\n  this.vertices = [];\n  this.colors = [];\n  this.normals = [];\n  this.uvs = [];\n  this.rawMesh = {\n    objectName: '',\n    groupName: '',\n    activeMtlName: '',\n    mtllibName: '',\n    // reset with new mesh\n    faceType: -1,\n    subGroups: [],\n    subGroupInUse: null,\n    smoothingGroup: {\n      splitMaterials: false,\n      normalized: -1,\n      real: -1\n    },\n    counts: {\n      doubleIndicesCount: 0,\n      faceCount: 0,\n      mtlCount: 0,\n      smoothingGroupCount: 0\n    }\n  };\n  this.inputObjectCount = 1;\n  this.outputObjectCount = 1;\n  this.globalCounts = {\n    vertices: 0,\n    faces: 0,\n    doubleIndicesCount: 0,\n    lineByte: 0,\n    currentByte: 0,\n    totalBytes: 0\n  };\n};\n\nOBJLoader2Parser.prototype = {\n  constructor: OBJLoader2Parser,\n  _resetRawMesh: function _resetRawMesh() {\n    // faces are stored according combined index of group, material and smoothingGroup (0 or not)\n    this.rawMesh.subGroups = [];\n    this.rawMesh.subGroupInUse = null;\n    this.rawMesh.smoothingGroup.normalized = -1;\n    this.rawMesh.smoothingGroup.real = -1; // this default index is required as it is possible to define faces without 'g' or 'usemtl'\n\n    this._pushSmoothingGroup(1);\n\n    this.rawMesh.counts.doubleIndicesCount = 0;\n    this.rawMesh.counts.faceCount = 0;\n    this.rawMesh.counts.mtlCount = 0;\n    this.rawMesh.counts.smoothingGroupCount = 0;\n  },\n\n  /**\n   * Tells whether a material shall be created per smoothing group.\n   *\n   * @param {boolean} materialPerSmoothingGroup=false\n   * @return {OBJLoader2Parser}\n   */\n  setMaterialPerSmoothingGroup: function setMaterialPerSmoothingGroup(materialPerSmoothingGroup) {\n    this.materialPerSmoothingGroup = materialPerSmoothingGroup === true;\n    return this;\n  },\n\n  /**\n   * Usually 'o' is meta-information and does not result in creation of new meshes, but mesh creation on occurrence of \"o\" can be enforced.\n   *\n   * @param {boolean} useOAsMesh=false\n   * @return {OBJLoader2Parser}\n   */\n  setUseOAsMesh: function setUseOAsMesh(useOAsMesh) {\n    this.useOAsMesh = useOAsMesh === true;\n    return this;\n  },\n\n  /**\n   * Instructs loaders to create indexed {@link BufferGeometry}.\n   *\n   * @param {boolean} useIndices=false\n   * @return {OBJLoader2Parser}\n   */\n  setUseIndices: function setUseIndices(useIndices) {\n    this.useIndices = useIndices === true;\n    return this;\n  },\n\n  /**\n   * Tells whether normals should be completely disregarded and regenerated.\n   *\n   * @param {boolean} disregardNormals=false\n   * @return {OBJLoader2Parser}\n   */\n  setDisregardNormals: function setDisregardNormals(disregardNormals) {\n    this.disregardNormals = disregardNormals === true;\n    return this;\n  },\n\n  /**\n   * Clears materials object and sets the new ones.\n   *\n   * @param {Object} materials Object with named materials\n   */\n  setMaterials: function setMaterials(materials) {\n    this.materials = Object.assign({}, materials);\n  },\n\n  /**\n   * Register a function that is called once an asset (mesh/material) becomes available.\n   *\n   * @param onAssetAvailable\n   * @return {OBJLoader2Parser}\n   */\n  setCallbackOnAssetAvailable: function setCallbackOnAssetAvailable(onAssetAvailable) {\n    if (onAssetAvailable !== null && onAssetAvailable !== undefined && onAssetAvailable instanceof Function) {\n      this.callbacks.onAssetAvailable = onAssetAvailable;\n    }\n\n    return this;\n  },\n\n  /**\n   * Register a function that is used to report overall processing progress.\n   *\n   * @param {Function} onProgress\n   * @return {OBJLoader2Parser}\n   */\n  setCallbackOnProgress: function setCallbackOnProgress(onProgress) {\n    if (onProgress !== null && onProgress !== undefined && onProgress instanceof Function) {\n      this.callbacks.onProgress = onProgress;\n    }\n\n    return this;\n  },\n\n  /**\n   * Register an error handler function that is called if errors occur. It can decide to just log or to throw an exception.\n   *\n   * @param {Function} onError\n   * @return {OBJLoader2Parser}\n   */\n  setCallbackOnError: function setCallbackOnError(onError) {\n    if (onError !== null && onError !== undefined && onError instanceof Function) {\n      this.callbacks.onError = onError;\n    }\n\n    return this;\n  },\n\n  /**\n   * Register a function that is called when parsing was completed.\n   *\n   * @param {Function} onLoad\n   * @return {OBJLoader2Parser}\n   */\n  setCallbackOnLoad: function setCallbackOnLoad(onLoad) {\n    if (onLoad !== null && onLoad !== undefined && onLoad instanceof Function) {\n      this.callbacks.onLoad = onLoad;\n    }\n\n    return this;\n  },\n\n  /**\n   * Announce parse progress feedback which is logged to the console.\n   * @private\n   *\n   * @param {string} text Textual description of the event\n   */\n  _onProgress: function _onProgress(text) {\n    var message = text ? text : '';\n\n    if (this.logging.enabled && this.logging.debug) {\n      console.log(message);\n    }\n  },\n\n  /**\n   * Announce error feedback which is logged as error message.\n   * @private\n   *\n   * @param {String} errorMessage The event containing the error\n   */\n  _onError: function _onError(errorMessage) {\n    if (this.logging.enabled && this.logging.debug) {\n      console.error(errorMessage);\n    }\n  },\n  _onAssetAvailable: function _onAssetAvailable(payload) {\n    var errorMessage = 'OBJLoader2Parser does not provide implementation for onAssetAvailable. Aborting...';\n    this.callbacks.onError(errorMessage);\n    throw errorMessage;\n  },\n  _onLoad: function _onLoad(object3d, message) {\n    console.log(\"You reached parser default onLoad callback: \" + message);\n  },\n\n  /**\n   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n   *\n   * @param {boolean} enabled True or false.\n   * @param {boolean} debug True or false.\n   *\n   * @return {OBJLoader2Parser}\n   */\n  setLogging: function setLogging(enabled, debug) {\n    this.logging.enabled = enabled === true;\n    this.logging.debug = debug === true;\n    return this;\n  },\n  _configure: function _configure() {\n    this._pushSmoothingGroup(1);\n\n    if (this.logging.enabled) {\n      var matKeys = Object.keys(this.materials);\n      var matNames = matKeys.length > 0 ? '\\n\\tmaterialNames:\\n\\t\\t- ' + matKeys.join('\\n\\t\\t- ') : '\\n\\tmaterialNames: None';\n      var printedConfig = 'OBJLoader.Parser configuration:' + matNames + '\\n\\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup + '\\n\\tuseOAsMesh: ' + this.useOAsMesh + '\\n\\tuseIndices: ' + this.useIndices + '\\n\\tdisregardNormals: ' + this.disregardNormals;\n      printedConfig += '\\n\\tcallbacks.onProgress: ' + this.callbacks.onProgress.name;\n      printedConfig += '\\n\\tcallbacks.onAssetAvailable: ' + this.callbacks.onAssetAvailable.name;\n      printedConfig += '\\n\\tcallbacks.onError: ' + this.callbacks.onError.name;\n      console.info(printedConfig);\n    }\n  },\n\n  /**\n   * Parse the provided arraybuffer\n   *\n   * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array\n   */\n  execute: function execute(arrayBuffer) {\n    if (this.logging.enabled) console.time('OBJLoader2Parser.execute');\n\n    this._configure();\n\n    var arrayBufferView = new Uint8Array(arrayBuffer);\n    this.contentRef = arrayBufferView;\n    var length = arrayBufferView.byteLength;\n    this.globalCounts.totalBytes = length;\n    var buffer = new Array(128);\n    var bufferPointer = 0;\n    var slashesCount = 0;\n    var word = '';\n    var currentByte = 0;\n\n    for (var code, _currentByte = 0; _currentByte < length; _currentByte++) {\n      code = arrayBufferView[_currentByte];\n\n      switch (code) {\n        // space\n        case 32:\n          if (word.length > 0) buffer[bufferPointer++] = word;\n          word = '';\n          break;\n        // slash\n\n        case 47:\n          if (word.length > 0) buffer[bufferPointer++] = word;\n          slashesCount++;\n          word = '';\n          break;\n        // LF\n\n        case 10:\n          this._processLine(buffer, bufferPointer, slashesCount, word, _currentByte);\n\n          word = '';\n          bufferPointer = 0;\n          slashesCount = 0;\n          break;\n        // CR\n\n        case 13:\n          break;\n\n        default:\n          word += String.fromCharCode(code);\n          break;\n      }\n    }\n\n    this._processLine(buffer, bufferPointer, slashesCount, word, currentByte);\n\n    this._finalizeParsing();\n\n    if (this.logging.enabled) console.timeEnd('OBJLoader2Parser.execute');\n  },\n\n  /**\n   * Parse the provided text\n   *\n   * @param {string} text OBJ data as string\n   */\n  executeLegacy: function executeLegacy(text) {\n    if (this.logging.enabled) console.time('OBJLoader2Parser.executeLegacy');\n\n    this._configure();\n\n    this.legacyMode = true;\n    this.contentRef = text;\n    var length = text.length;\n    this.globalCounts.totalBytes = length;\n    var buffer = new Array(128);\n    var bufferPointer = 0;\n    var slashesCount = 0;\n    var word = '';\n    var currentByte = 0;\n\n    for (var char; currentByte < length; currentByte++) {\n      char = text[currentByte];\n\n      switch (char) {\n        case ' ':\n          if (word.length > 0) buffer[bufferPointer++] = word;\n          word = '';\n          break;\n\n        case '/':\n          if (word.length > 0) buffer[bufferPointer++] = word;\n          slashesCount++;\n          word = '';\n          break;\n\n        case '\\n':\n          this._processLine(buffer, bufferPointer, slashesCount, word, currentByte);\n\n          word = '';\n          bufferPointer = 0;\n          slashesCount = 0;\n          break;\n\n        case '\\r':\n          break;\n\n        default:\n          word += char;\n      }\n    }\n\n    this._processLine(buffer, bufferPointer, word, slashesCount);\n\n    this._finalizeParsing();\n\n    if (this.logging.enabled) console.timeEnd('OBJLoader2Parser.executeLegacy');\n  },\n  _processLine: function _processLine(buffer, bufferPointer, slashesCount, word, currentByte) {\n    this.globalCounts.lineByte = this.globalCounts.currentByte;\n    this.globalCounts.currentByte = currentByte;\n    if (bufferPointer < 1) return;\n    if (word.length > 0) buffer[bufferPointer++] = word;\n\n    var reconstructString = function reconstructString(content, legacyMode, start, stop) {\n      var line = '';\n\n      if (stop > start) {\n        var _i;\n\n        if (legacyMode) {\n          for (_i = start; _i < stop; _i++) {\n            line += content[_i];\n          }\n        } else {\n          for (_i = start; _i < stop; _i++) {\n            line += String.fromCharCode(content[_i]);\n          }\n        }\n\n        line = line.trim();\n      }\n\n      return line;\n    };\n\n    var bufferLength, length, i, lineDesignation;\n    lineDesignation = buffer[0];\n\n    switch (lineDesignation) {\n      case 'v':\n        this.vertices.push(parseFloat(buffer[1]));\n        this.vertices.push(parseFloat(buffer[2]));\n        this.vertices.push(parseFloat(buffer[3]));\n\n        if (bufferPointer > 4) {\n          this.colors.push(parseFloat(buffer[4]));\n          this.colors.push(parseFloat(buffer[5]));\n          this.colors.push(parseFloat(buffer[6]));\n        }\n\n        break;\n\n      case 'vt':\n        this.uvs.push(parseFloat(buffer[1]));\n        this.uvs.push(parseFloat(buffer[2]));\n        break;\n\n      case 'vn':\n        this.normals.push(parseFloat(buffer[1]));\n        this.normals.push(parseFloat(buffer[2]));\n        this.normals.push(parseFloat(buffer[3]));\n        break;\n\n      case 'f':\n        bufferLength = bufferPointer - 1; // \"f vertex ...\"\n\n        if (slashesCount === 0) {\n          this._checkFaceType(0);\n\n          for (i = 2, length = bufferLength; i < length; i++) {\n            this._buildFace(buffer[1]);\n\n            this._buildFace(buffer[i]);\n\n            this._buildFace(buffer[i + 1]);\n          } // \"f vertex/uv ...\"\n\n        } else if (bufferLength === slashesCount * 2) {\n          this._checkFaceType(1);\n\n          for (i = 3, length = bufferLength - 2; i < length; i += 2) {\n            this._buildFace(buffer[1], buffer[2]);\n\n            this._buildFace(buffer[i], buffer[i + 1]);\n\n            this._buildFace(buffer[i + 2], buffer[i + 3]);\n          } // \"f vertex/uv/normal ...\"\n\n        } else if (bufferLength * 2 === slashesCount * 3) {\n          this._checkFaceType(2);\n\n          for (i = 4, length = bufferLength - 3; i < length; i += 3) {\n            this._buildFace(buffer[1], buffer[2], buffer[3]);\n\n            this._buildFace(buffer[i], buffer[i + 1], buffer[i + 2]);\n\n            this._buildFace(buffer[i + 3], buffer[i + 4], buffer[i + 5]);\n          } // \"f vertex//normal ...\"\n\n        } else {\n          this._checkFaceType(3);\n\n          for (i = 3, length = bufferLength - 2; i < length; i += 2) {\n            this._buildFace(buffer[1], undefined, buffer[2]);\n\n            this._buildFace(buffer[i], undefined, buffer[i + 1]);\n\n            this._buildFace(buffer[i + 2], undefined, buffer[i + 3]);\n          }\n        }\n\n        break;\n\n      case 'l':\n      case 'p':\n        bufferLength = bufferPointer - 1;\n\n        if (bufferLength === slashesCount * 2) {\n          this._checkFaceType(4);\n\n          for (i = 1, length = bufferLength + 1; i < length; i += 2) {\n            this._buildFace(buffer[i], buffer[i + 1]);\n          }\n        } else {\n          this._checkFaceType(lineDesignation === 'l' ? 5 : 6);\n\n          for (i = 1, length = bufferLength + 1; i < length; i++) {\n            this._buildFace(buffer[i]);\n          }\n        }\n\n        break;\n\n      case 's':\n        this._pushSmoothingGroup(buffer[1]);\n\n        break;\n\n      case 'g':\n        // 'g' leads to creation of mesh if valid data (faces declaration was done before), otherwise only groupName gets set\n        this._processCompletedMesh();\n\n        this.rawMesh.groupName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);\n        break;\n\n      case 'o':\n        // 'o' is meta-information and usually does not result in creation of new meshes, but can be enforced with \"useOAsMesh\"\n        if (this.useOAsMesh) this._processCompletedMesh();\n        this.rawMesh.objectName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);\n        break;\n\n      case 'mtllib':\n        this.rawMesh.mtllibName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);\n        break;\n\n      case 'usemtl':\n        var mtlName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);\n\n        if (mtlName !== '' && this.rawMesh.activeMtlName !== mtlName) {\n          this.rawMesh.activeMtlName = mtlName;\n          this.rawMesh.counts.mtlCount++;\n\n          this._checkSubGroup();\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  },\n  _pushSmoothingGroup: function _pushSmoothingGroup(smoothingGroup) {\n    var smoothingGroupInt = parseInt(smoothingGroup);\n\n    if (isNaN(smoothingGroupInt)) {\n      smoothingGroupInt = smoothingGroup === \"off\" ? 0 : 1;\n    }\n\n    var smoothCheck = this.rawMesh.smoothingGroup.normalized;\n    this.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? smoothingGroupInt : smoothingGroupInt === 0 ? 0 : 1;\n    this.rawMesh.smoothingGroup.real = smoothingGroupInt;\n\n    if (smoothCheck !== smoothingGroupInt) {\n      this.rawMesh.counts.smoothingGroupCount++;\n\n      this._checkSubGroup();\n    }\n  },\n\n  /**\n   * Expanded faceTypes include all four face types, both line types and the point type\n   * faceType = 0: \"f vertex ...\"\n   * faceType = 1: \"f vertex/uv ...\"\n   * faceType = 2: \"f vertex/uv/normal ...\"\n   * faceType = 3: \"f vertex//normal ...\"\n   * faceType = 4: \"l vertex/uv ...\" or \"l vertex ...\"\n   * faceType = 5: \"l vertex ...\"\n   * faceType = 6: \"p vertex ...\"\n   */\n  _checkFaceType: function _checkFaceType(faceType) {\n    if (this.rawMesh.faceType !== faceType) {\n      this._processCompletedMesh();\n\n      this.rawMesh.faceType = faceType;\n\n      this._checkSubGroup();\n    }\n  },\n  _checkSubGroup: function _checkSubGroup() {\n    var index = this.rawMesh.activeMtlName + '|' + this.rawMesh.smoothingGroup.normalized;\n    this.rawMesh.subGroupInUse = this.rawMesh.subGroups[index];\n\n    if (this.rawMesh.subGroupInUse === undefined || this.rawMesh.subGroupInUse === null) {\n      this.rawMesh.subGroupInUse = {\n        index: index,\n        objectName: this.rawMesh.objectName,\n        groupName: this.rawMesh.groupName,\n        materialName: this.rawMesh.activeMtlName,\n        smoothingGroup: this.rawMesh.smoothingGroup.normalized,\n        vertices: [],\n        indexMappingsCount: 0,\n        indexMappings: [],\n        indices: [],\n        colors: [],\n        uvs: [],\n        normals: []\n      };\n      this.rawMesh.subGroups[index] = this.rawMesh.subGroupInUse;\n    }\n  },\n  _buildFace: function _buildFace(faceIndexV, faceIndexU, faceIndexN) {\n    var subGroupInUse = this.rawMesh.subGroupInUse;\n    var scope = this;\n\n    var updateSubGroupInUse = function updateSubGroupInUse() {\n      var faceIndexVi = parseInt(faceIndexV);\n      var indexPointerV = 3 * (faceIndexVi > 0 ? faceIndexVi - 1 : faceIndexVi + scope.vertices.length / 3);\n      var indexPointerC = scope.colors.length > 0 ? indexPointerV : null;\n      var vertices = subGroupInUse.vertices;\n      vertices.push(scope.vertices[indexPointerV++]);\n      vertices.push(scope.vertices[indexPointerV++]);\n      vertices.push(scope.vertices[indexPointerV]);\n\n      if (indexPointerC !== null) {\n        var colors = subGroupInUse.colors;\n        colors.push(scope.colors[indexPointerC++]);\n        colors.push(scope.colors[indexPointerC++]);\n        colors.push(scope.colors[indexPointerC]);\n      }\n\n      if (faceIndexU) {\n        var faceIndexUi = parseInt(faceIndexU);\n        var indexPointerU = 2 * (faceIndexUi > 0 ? faceIndexUi - 1 : faceIndexUi + scope.uvs.length / 2);\n        var uvs = subGroupInUse.uvs;\n        uvs.push(scope.uvs[indexPointerU++]);\n        uvs.push(scope.uvs[indexPointerU]);\n      }\n\n      if (faceIndexN && !scope.disregardNormals) {\n        var faceIndexNi = parseInt(faceIndexN);\n        var indexPointerN = 3 * (faceIndexNi > 0 ? faceIndexNi - 1 : faceIndexNi + scope.normals.length / 3);\n        var normals = subGroupInUse.normals;\n        normals.push(scope.normals[indexPointerN++]);\n        normals.push(scope.normals[indexPointerN++]);\n        normals.push(scope.normals[indexPointerN]);\n      }\n    };\n\n    if (this.useIndices) {\n      if (this.disregardNormals) faceIndexN = undefined;\n      var mappingName = faceIndexV + (faceIndexU ? '_' + faceIndexU : '_n') + (faceIndexN ? '_' + faceIndexN : '_n');\n      var indicesPointer = subGroupInUse.indexMappings[mappingName];\n\n      if (indicesPointer === undefined || indicesPointer === null) {\n        indicesPointer = this.rawMesh.subGroupInUse.vertices.length / 3;\n        updateSubGroupInUse();\n        subGroupInUse.indexMappings[mappingName] = indicesPointer;\n        subGroupInUse.indexMappingsCount++;\n      } else {\n        this.rawMesh.counts.doubleIndicesCount++;\n      }\n\n      subGroupInUse.indices.push(indicesPointer);\n    } else {\n      updateSubGroupInUse();\n    }\n\n    this.rawMesh.counts.faceCount++;\n  },\n  _createRawMeshReport: function _createRawMeshReport(inputObjectCount) {\n    return 'Input Object number: ' + inputObjectCount + '\\n\\tObject name: ' + this.rawMesh.objectName + '\\n\\tGroup name: ' + this.rawMesh.groupName + '\\n\\tMtllib name: ' + this.rawMesh.mtllibName + '\\n\\tVertex count: ' + this.vertices.length / 3 + '\\n\\tNormal count: ' + this.normals.length / 3 + '\\n\\tUV count: ' + this.uvs.length / 2 + '\\n\\tSmoothingGroup count: ' + this.rawMesh.counts.smoothingGroupCount + '\\n\\tMaterial count: ' + this.rawMesh.counts.mtlCount + '\\n\\tReal MeshOutputGroup count: ' + this.rawMesh.subGroups.length;\n  },\n\n  /**\n   * Clear any empty subGroup and calculate absolute vertex, normal and uv counts\n   */\n  _finalizeRawMesh: function _finalizeRawMesh() {\n    var meshOutputGroupTemp = [];\n    var meshOutputGroup;\n    var absoluteVertexCount = 0;\n    var absoluteIndexMappingsCount = 0;\n    var absoluteIndexCount = 0;\n    var absoluteColorCount = 0;\n    var absoluteNormalCount = 0;\n    var absoluteUvCount = 0;\n    var indices;\n\n    for (var name in this.rawMesh.subGroups) {\n      meshOutputGroup = this.rawMesh.subGroups[name];\n\n      if (meshOutputGroup.vertices.length > 0) {\n        indices = meshOutputGroup.indices;\n\n        if (indices.length > 0 && absoluteIndexMappingsCount > 0) {\n          for (var i = 0; i < indices.length; i++) {\n            indices[i] = indices[i] + absoluteIndexMappingsCount;\n          }\n        }\n\n        meshOutputGroupTemp.push(meshOutputGroup);\n        absoluteVertexCount += meshOutputGroup.vertices.length;\n        absoluteIndexMappingsCount += meshOutputGroup.indexMappingsCount;\n        absoluteIndexCount += meshOutputGroup.indices.length;\n        absoluteColorCount += meshOutputGroup.colors.length;\n        absoluteUvCount += meshOutputGroup.uvs.length;\n        absoluteNormalCount += meshOutputGroup.normals.length;\n      }\n    } // do not continue if no result\n\n\n    var result = null;\n\n    if (meshOutputGroupTemp.length > 0) {\n      result = {\n        name: this.rawMesh.groupName !== '' ? this.rawMesh.groupName : this.rawMesh.objectName,\n        subGroups: meshOutputGroupTemp,\n        absoluteVertexCount: absoluteVertexCount,\n        absoluteIndexCount: absoluteIndexCount,\n        absoluteColorCount: absoluteColorCount,\n        absoluteNormalCount: absoluteNormalCount,\n        absoluteUvCount: absoluteUvCount,\n        faceCount: this.rawMesh.counts.faceCount,\n        doubleIndicesCount: this.rawMesh.counts.doubleIndicesCount\n      };\n    }\n\n    return result;\n  },\n  _processCompletedMesh: function _processCompletedMesh() {\n    var result = this._finalizeRawMesh();\n\n    var haveMesh = result !== null;\n\n    if (haveMesh) {\n      if (this.colors.length > 0 && this.colors.length !== this.vertices.length) {\n        this.callbacks.onError('Vertex Colors were detected, but vertex count and color count do not match!');\n      }\n\n      if (this.logging.enabled && this.logging.debug) console.debug(this._createRawMeshReport(this.inputObjectCount));\n      this.inputObjectCount++;\n\n      this._buildMesh(result);\n\n      var progressBytesPercent = this.globalCounts.currentByte / this.globalCounts.totalBytes;\n\n      this._onProgress('Completed [o: ' + this.rawMesh.objectName + ' g:' + this.rawMesh.groupName + '' + '] Total progress: ' + (progressBytesPercent * 100).toFixed(2) + '%');\n\n      this._resetRawMesh();\n    }\n\n    return haveMesh;\n  },\n\n  /**\n   * SubGroups are transformed to too intermediate format that is forwarded to the MeshReceiver.\n   * It is ensured that SubGroups only contain objects with vertices (no need to check).\n   *\n   * @param result\n   */\n  _buildMesh: function _buildMesh(result) {\n    var meshOutputGroups = result.subGroups;\n    var vertexFA = new Float32Array(result.absoluteVertexCount);\n    this.globalCounts.vertices += result.absoluteVertexCount / 3;\n    this.globalCounts.faces += result.faceCount;\n    this.globalCounts.doubleIndicesCount += result.doubleIndicesCount;\n    var indexUA = result.absoluteIndexCount > 0 ? new Uint32Array(result.absoluteIndexCount) : null;\n    var colorFA = result.absoluteColorCount > 0 ? new Float32Array(result.absoluteColorCount) : null;\n    var normalFA = result.absoluteNormalCount > 0 ? new Float32Array(result.absoluteNormalCount) : null;\n    var uvFA = result.absoluteUvCount > 0 ? new Float32Array(result.absoluteUvCount) : null;\n    var haveVertexColors = colorFA !== null;\n    var meshOutputGroup;\n    var materialNames = [];\n    var createMultiMaterial = meshOutputGroups.length > 1;\n    var materialIndex = 0;\n    var materialIndexMapping = [];\n    var selectedMaterialIndex;\n    var materialGroup;\n    var materialGroups = [];\n    var vertexFAOffset = 0;\n    var indexUAOffset = 0;\n    var colorFAOffset = 0;\n    var normalFAOffset = 0;\n    var uvFAOffset = 0;\n    var materialGroupOffset = 0;\n    var materialGroupLength = 0;\n    var materialOrg, material, materialName, materialNameOrg; // only one specific face type\n\n    for (var oodIndex in meshOutputGroups) {\n      if (!meshOutputGroups.hasOwnProperty(oodIndex)) continue;\n      meshOutputGroup = meshOutputGroups[oodIndex];\n      materialNameOrg = meshOutputGroup.materialName;\n\n      if (this.rawMesh.faceType < 4) {\n        materialName = materialNameOrg + (haveVertexColors ? '_vertexColor' : '') + (meshOutputGroup.smoothingGroup === 0 ? '_flat' : '');\n      } else {\n        materialName = this.rawMesh.faceType === 6 ? 'defaultPointMaterial' : 'defaultLineMaterial';\n      }\n\n      materialOrg = this.materials[materialNameOrg];\n      material = this.materials[materialName]; // both original and derived names do not lead to an existing material => need to use a default material\n\n      if ((materialOrg === undefined || materialOrg === null) && (material === undefined || material === null)) {\n        materialName = haveVertexColors ? 'defaultVertexColorMaterial' : 'defaultMaterial';\n        material = this.materials[materialName];\n\n        if (this.logging.enabled) {\n          console.info('object_group \"' + meshOutputGroup.objectName + '_' + meshOutputGroup.groupName + '\" was defined with unresolvable material \"' + materialNameOrg + '\"! Assigning \"' + materialName + '\".');\n        }\n      }\n\n      if (material === undefined || material === null) {\n        var materialCloneInstructions = {\n          materialNameOrg: materialNameOrg,\n          materialName: materialName,\n          materialProperties: {\n            vertexColors: haveVertexColors ? 2 : 0,\n            flatShading: meshOutputGroup.smoothingGroup === 0\n          }\n        };\n        var payload = {\n          cmd: 'assetAvailable',\n          type: 'material',\n          materials: {\n            materialCloneInstructions: materialCloneInstructions\n          }\n        };\n        this.callbacks.onAssetAvailable(payload); // only set materials if they don't exist, yet\n\n        var matCheck = this.materials[materialName];\n\n        if (matCheck === undefined || matCheck === null) {\n          this.materials[materialName] = materialCloneInstructions;\n        }\n      }\n\n      if (createMultiMaterial) {\n        // re-use material if already used before. Reduces materials array size and eliminates duplicates\n        selectedMaterialIndex = materialIndexMapping[materialName];\n\n        if (!selectedMaterialIndex) {\n          selectedMaterialIndex = materialIndex;\n          materialIndexMapping[materialName] = materialIndex;\n          materialNames.push(materialName);\n          materialIndex++;\n        }\n\n        materialGroupLength = this.useIndices ? meshOutputGroup.indices.length : meshOutputGroup.vertices.length / 3;\n        materialGroup = {\n          start: materialGroupOffset,\n          count: materialGroupLength,\n          index: selectedMaterialIndex\n        };\n        materialGroups.push(materialGroup);\n        materialGroupOffset += materialGroupLength;\n      } else {\n        materialNames.push(materialName);\n      }\n\n      vertexFA.set(meshOutputGroup.vertices, vertexFAOffset);\n      vertexFAOffset += meshOutputGroup.vertices.length;\n\n      if (indexUA) {\n        indexUA.set(meshOutputGroup.indices, indexUAOffset);\n        indexUAOffset += meshOutputGroup.indices.length;\n      }\n\n      if (colorFA) {\n        colorFA.set(meshOutputGroup.colors, colorFAOffset);\n        colorFAOffset += meshOutputGroup.colors.length;\n      }\n\n      if (normalFA) {\n        normalFA.set(meshOutputGroup.normals, normalFAOffset);\n        normalFAOffset += meshOutputGroup.normals.length;\n      }\n\n      if (uvFA) {\n        uvFA.set(meshOutputGroup.uvs, uvFAOffset);\n        uvFAOffset += meshOutputGroup.uvs.length;\n      }\n\n      if (this.logging.enabled && this.logging.debug) {\n        var materialIndexLine = '';\n\n        if (selectedMaterialIndex) {\n          materialIndexLine = '\\n\\t\\tmaterialIndex: ' + selectedMaterialIndex;\n        }\n\n        var createdReport = '\\tOutput Object no.: ' + this.outputObjectCount + '\\n\\t\\tgroupName: ' + meshOutputGroup.groupName + '\\n\\t\\tIndex: ' + meshOutputGroup.index + '\\n\\t\\tfaceType: ' + this.rawMesh.faceType + '\\n\\t\\tmaterialName: ' + meshOutputGroup.materialName + '\\n\\t\\tsmoothingGroup: ' + meshOutputGroup.smoothingGroup + materialIndexLine + '\\n\\t\\tobjectName: ' + meshOutputGroup.objectName + '\\n\\t\\t#vertices: ' + meshOutputGroup.vertices.length / 3 + '\\n\\t\\t#indices: ' + meshOutputGroup.indices.length + '\\n\\t\\t#colors: ' + meshOutputGroup.colors.length / 3 + '\\n\\t\\t#uvs: ' + meshOutputGroup.uvs.length / 2 + '\\n\\t\\t#normals: ' + meshOutputGroup.normals.length / 3;\n        console.debug(createdReport);\n      }\n    }\n\n    this.outputObjectCount++;\n    this.callbacks.onAssetAvailable({\n      cmd: 'assetAvailable',\n      type: 'mesh',\n      progress: {\n        numericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes\n      },\n      params: {\n        meshName: result.name\n      },\n      materials: {\n        multiMaterial: createMultiMaterial,\n        materialNames: materialNames,\n        materialGroups: materialGroups\n      },\n      buffers: {\n        vertices: vertexFA,\n        indices: indexUA,\n        colors: colorFA,\n        normals: normalFA,\n        uvs: uvFA\n      },\n      // 0: mesh, 1: line, 2: point\n      geometryType: this.rawMesh.faceType < 4 ? 0 : this.rawMesh.faceType === 6 ? 2 : 1\n    }, [vertexFA.buffer], indexUA !== null ? [indexUA.buffer] : null, colorFA !== null ? [colorFA.buffer] : null, normalFA !== null ? [normalFA.buffer] : null, uvFA !== null ? [uvFA.buffer] : null);\n  },\n  _finalizeParsing: function _finalizeParsing() {\n    if (this.logging.enabled) console.info('Global output object count: ' + this.outputObjectCount);\n\n    if (this._processCompletedMesh() && this.logging.enabled) {\n      var parserFinalReport = 'Overall counts: ' + '\\n\\tVertices: ' + this.globalCounts.vertices + '\\n\\tFaces: ' + this.globalCounts.faces + '\\n\\tMultiple definitions: ' + this.globalCounts.doubleIndicesCount;\n      console.info(parserFinalReport);\n    }\n  }\n};\nexport { OBJLoader2Parser };","map":null,"metadata":{},"sourceType":"module"}