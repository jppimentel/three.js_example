{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\Jo\\xE3o Paulo Pimentel\\\\Documents\\\\Projetos JS\\\\three_example\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\n\n/**\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\nimport { FileLoader, Object3D, Loader } from \"../../../build/three.module.js\";\nimport { OBJLoader2Parser } from \"./obj2/OBJLoader2Parser.js\";\nimport { MeshReceiver } from \"./obj2/shared/MeshReceiver.js\";\nimport { MaterialHandler } from \"./obj2/shared/MaterialHandler.js\";\n/**\n * Creates a new OBJLoader2. Use it to load OBJ data from files or to parse OBJ data from arraybuffer or text.\n *\n * @param {LoadingManager} [manager] The loadingManager for the loader to use. Default is {@link LoadingManager}\n * @constructor\n */\n\nvar OBJLoader2 = function OBJLoader2(manager) {\n  Loader.call(this, manager);\n  this.parser = new OBJLoader2Parser();\n  this.modelName = '';\n  this.instanceNo = 0;\n  this.baseObject3d = new Object3D();\n  this.materialHandler = new MaterialHandler();\n  this.meshReceiver = new MeshReceiver(this.materialHandler); // as OBJLoader2 is no longer derived from OBJLoader2Parser, we need to override the default onAssetAvailable callback\n\n  var scope = this;\n\n  var defaultOnAssetAvailable = function defaultOnAssetAvailable(payload) {\n    scope._onAssetAvailable(payload);\n  };\n\n  this.parser.setCallbackOnAssetAvailable(defaultOnAssetAvailable);\n};\n\nOBJLoader2.OBJLOADER2_VERSION = '3.2.0';\nconsole.info('Using OBJLoader2 version: ' + OBJLoader2.OBJLOADER2_VERSION);\nOBJLoader2.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: OBJLoader2,\n\n  /**\n   * See {@link OBJLoader2Parser.setLogging}\n   * @return {OBJLoader2}\n   */\n  setLogging: function setLogging(enabled, debug) {\n    this.parser.setLogging(enabled, debug);\n    return this;\n  },\n\n  /**\n   * See {@link OBJLoader2Parser.setMaterialPerSmoothingGroup}\n   * @return {OBJLoader2}\n   */\n  setMaterialPerSmoothingGroup: function setMaterialPerSmoothingGroup(materialPerSmoothingGroup) {\n    this.parser.setMaterialPerSmoothingGroup(materialPerSmoothingGroup);\n    return this;\n  },\n\n  /**\n   * See {@link OBJLoader2Parser.setUseOAsMesh}\n   * @return {OBJLoader2}\n   */\n  setUseOAsMesh: function setUseOAsMesh(useOAsMesh) {\n    this.parser.setUseOAsMesh(useOAsMesh);\n    return this;\n  },\n\n  /**\n   * See {@link OBJLoader2Parser.setUseIndices}\n   * @return {OBJLoader2}\n   */\n  setUseIndices: function setUseIndices(useIndices) {\n    this.parser.setUseIndices(useIndices);\n    return this;\n  },\n\n  /**\n   * See {@link OBJLoader2Parser.setDisregardNormals}\n   * @return {OBJLoader2}\n   */\n  setDisregardNormals: function setDisregardNormals(disregardNormals) {\n    this.parser.setDisregardNormals(disregardNormals);\n    return this;\n  },\n\n  /**\n   * Set the name of the model.\n   *\n   * @param {string} modelName\n   * @return {OBJLoader2}\n   */\n  setModelName: function setModelName(modelName) {\n    this.modelName = modelName ? modelName : this.modelName;\n    return this;\n  },\n\n  /**\n   * Set the node where the loaded objects will be attached directly.\n   *\n   * @param {Object3D} baseObject3d Object already attached to scenegraph where new meshes will be attached to\n   * @return {OBJLoader2}\n   */\n  setBaseObject3d: function setBaseObject3d(baseObject3d) {\n    this.baseObject3d = baseObject3d === undefined || baseObject3d === null ? this.baseObject3d : baseObject3d;\n    return this;\n  },\n\n  /**\n   * Add materials as associated array.\n   *\n   * @param {Object} materials Object with named {@link Material}\n   * @param overrideExisting boolean Override existing material\n   * @return {OBJLoader2}\n   */\n  addMaterials: function addMaterials(materials, overrideExisting) {\n    this.materialHandler.addMaterials(materials, overrideExisting);\n    return this;\n  },\n\n  /**\n   * See {@link OBJLoader2Parser.setCallbackOnAssetAvailable}\n   * @return {OBJLoader2}\n   */\n  setCallbackOnAssetAvailable: function setCallbackOnAssetAvailable(onAssetAvailable) {\n    this.parser.setCallbackOnAssetAvailable(onAssetAvailable);\n    return this;\n  },\n\n  /**\n   * See {@link OBJLoader2Parser.setCallbackOnProgress}\n   * @return {OBJLoader2}\n   */\n  setCallbackOnProgress: function setCallbackOnProgress(onProgress) {\n    this.parser.setCallbackOnProgress(onProgress);\n    return this;\n  },\n\n  /**\n   * See {@link OBJLoader2Parser.setCallbackOnError}\n   * @return {OBJLoader2}\n   */\n  setCallbackOnError: function setCallbackOnError(onError) {\n    this.parser.setCallbackOnError(onError);\n    return this;\n  },\n\n  /**\n   * See {@link OBJLoader2Parser.setCallbackOnLoad}\n   * @return {OBJLoader2}\n   */\n  setCallbackOnLoad: function setCallbackOnLoad(onLoad) {\n    this.parser.setCallbackOnLoad(onLoad);\n    return this;\n  },\n\n  /**\n   * Register a function that is called once a single mesh is available and it could be altered by the supplied function.\n   *\n   * @param {Function} [onMeshAlter]\n   * @return {OBJLoader2}\n   */\n  setCallbackOnMeshAlter: function setCallbackOnMeshAlter(onMeshAlter) {\n    this.meshReceiver._setCallbacks(this.parser.callbacks.onProgress, onMeshAlter);\n\n    return this;\n  },\n\n  /**\n   * Register a function that is called once all materials have been loaded and they could be altered by the supplied function.\n   *\n   * @param {Function} [onLoadMaterials]\n   * @return {OBJLoader2}\n   */\n  setCallbackOnLoadMaterials: function setCallbackOnLoadMaterials(onLoadMaterials) {\n    this.materialHandler._setCallbacks(onLoadMaterials);\n\n    return this;\n  },\n\n  /**\n   * Use this convenient method to load a file at the given URL. By default the fileLoader uses an ArrayBuffer.\n   *\n   * @param {string}  url A string containing the path/URL of the file to be loaded.\n   * @param {function} onLoad A function to be called after loading is successfully completed. The function receives loaded Object3D as an argument.\n   * @param {function} [onFileLoadProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.\n   * @param {function} [onError] A function to be called if an error occurs during loading. The function receives the error as an argument.\n   * @param {function} [onMeshAlter] Called after every single mesh is made available by the parser\n   */\n  load: function load(url, onLoad, onFileLoadProgress, onError, onMeshAlter) {\n    var scope = this;\n\n    if (onLoad === null || onLoad === undefined || !(onLoad instanceof Function)) {\n      var errorMessage = 'onLoad is not a function! Aborting...';\n      scope.parser.callbacks.onError(errorMessage);\n      throw errorMessage;\n    } else {\n      this.parser.setCallbackOnLoad(onLoad);\n    }\n\n    if (onError === null || onError === undefined || !(onError instanceof Function)) {\n      onError = function onError(event) {\n        var errorMessage = event;\n\n        if (event.currentTarget && event.currentTarget.statusText !== null) {\n          errorMessage = 'Error occurred while downloading!\\nurl: ' + event.currentTarget.responseURL + '\\nstatus: ' + event.currentTarget.statusText;\n        }\n\n        scope.parser.callbacks.onError(errorMessage);\n      };\n    }\n\n    if (!url) {\n      onError('An invalid url was provided. Unable to continue!');\n    }\n\n    var urlFull = new URL(url, window.location.href).href;\n    var filename = urlFull;\n    var urlParts = urlFull.split('/');\n\n    if (urlParts.length > 2) {\n      filename = urlParts[urlParts.length - 1];\n      this.path = urlParts.slice(0, urlParts.length - 1).join('/') + '/';\n    }\n\n    if (onFileLoadProgress === null || onFileLoadProgress === undefined || !(onFileLoadProgress instanceof Function)) {\n      var numericalValueRef = 0;\n      var numericalValue = 0;\n\n      onFileLoadProgress = function onFileLoadProgress(event) {\n        if (!event.lengthComputable) return;\n        numericalValue = event.loaded / event.total;\n\n        if (numericalValue > numericalValueRef) {\n          numericalValueRef = numericalValue;\n          var output = 'Download of \"' + url + '\": ' + (numericalValue * 100).toFixed(2) + '%';\n          scope.parser.callbacks.onProgress('progressLoad', output, numericalValue);\n        }\n      };\n    }\n\n    this.setCallbackOnMeshAlter(onMeshAlter);\n\n    var fileLoaderOnLoad = function fileLoaderOnLoad(content) {\n      scope.parser.callbacks.onLoad(scope.parse(content), \"OBJLoader2#load: Parsing completed\");\n    };\n\n    var fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path || this.resourcePath);\n    fileLoader.setResponseType('arraybuffer');\n    fileLoader.load(filename, fileLoaderOnLoad, onFileLoadProgress, onError);\n  },\n\n  /**\n   * Parses OBJ data synchronously from arraybuffer or string and returns the {@link Object3D}.\n   *\n   * @param {arraybuffer|string} content OBJ data as Uint8Array or String\n   * @return {Object3D}\n   */\n  parse: function parse(content) {\n    // fast-fail in case of illegal data\n    if (content === null || content === undefined) {\n      throw 'Provided content is not a valid ArrayBuffer or String. Unable to continue parsing';\n    }\n\n    if (this.parser.logging.enabled) {\n      console.time('OBJLoader parse: ' + this.modelName);\n    } // Create default materials beforehand, but do not override previously set materials (e.g. during init)\n\n\n    this.materialHandler.createDefaultMaterials(false); // code works directly on the material references, parser clear its materials before updating\n\n    this.parser.setMaterials(this.materialHandler.getMaterials());\n\n    if (content instanceof ArrayBuffer || content instanceof Uint8Array) {\n      if (this.parser.logging.enabled) console.info('Parsing arrayBuffer...');\n      this.parser.execute(content);\n    } else if (typeof content === 'string' || content instanceof String) {\n      if (this.parser.logging.enabled) console.info('Parsing text...');\n      this.parser.executeLegacy(content);\n    } else {\n      this.parser.callbacks.onError('Provided content was neither of type String nor Uint8Array! Aborting...');\n    }\n\n    if (this.parser.logging.enabled) {\n      console.timeEnd('OBJLoader parse: ' + this.modelName);\n    }\n\n    return this.baseObject3d;\n  },\n  _onAssetAvailable: function _onAssetAvailable(payload) {\n    if (payload.cmd !== 'assetAvailable') return;\n\n    if (payload.type === 'mesh') {\n      var meshes = this.meshReceiver.buildMeshes(payload);\n\n      var _iterator = _createForOfIteratorHelper(meshes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var mesh = _step.value;\n          this.baseObject3d.add(mesh);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } else if (payload.type === 'material') {\n      this.materialHandler.addPayloadMaterials(payload);\n    }\n  }\n});\nexport { OBJLoader2 };","map":null,"metadata":{},"sourceType":"module"}